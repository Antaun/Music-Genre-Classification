# -*- coding: utf-8 -*-
"""MGC.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12U67bbVeImcHfsMrRzGJxMHTKgWV_tP8
"""

from google.colab import drive
drive.mount('/content/drive')

import os
Root = "/content/drive/MyDrive/Colab_Notebooks/Music_Genre_Classification"
os.chdir(Root)

"""**Import all necessary Libraries and Tools**"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
import os
import IPython.display as ipd
import librosa
import librosa.display
import time
import seaborn as sns
import tensorflow as tf
import matplotlib.pyplot as plt
import sklearn as sklearn
# %matplotlib inline

from datetime import datetime 
from sklearn import metrics
from sklearn.neighbors import KNeighborsClassifier
from sklearn.svm import SVC
from sklearn.metrics import confusion_matrix, classification_report, accuracy_score, precision_score, recall_score, f1_score
from sklearn.preprocessing import LabelEncoder
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
from tqdm import tqdm
from tensorflow import keras
from tensorflow.keras.utils import to_categorical
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense,Dropout,Activation,Flatten
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.callbacks import ModelCheckpoint

audio_dataset_path='/content/drive/MyDrive/Colab_Notebooks/Music_Genre_Classification/dataset/Data/genres_original'
metadata=pd.read_csv('/content/drive/MyDrive/Colab_Notebooks/Music_Genre_Classification/dataset/Data/features_30_sec.csv')
metadata.head()

"""**Feature Extractor Function**"""

def features_extractor(file):
    audio, sample_rate = librosa.load(file_name, res_type='kaiser_fast') 
    mfccs_features = librosa.feature.mfcc(y=audio, sr=sample_rate, n_mfcc=58)
    mfccs_scaled_features = np.mean(mfccs_features.T,axis=0)
    
    return mfccs_scaled_features

### Now we iterate through every audio file and extract features using Mel-Frequency Cepstral Coefficients
extracted_features=[]
for index_num,row in tqdm(metadata.iterrows()):
    try:
        final_class_labels=row["label"]
        file_name = os.path.join(os.path.abspath(audio_dataset_path), final_class_labels+'/',str(row["filename"]))    
        data=features_extractor(file_name)
        extracted_features.append([data,final_class_labels])
    except Exception as e:
        print(f"Error: {e}")
        continue

### Converting extracted features to Pandas dataframe
extracted_features_df=pd.DataFrame(extracted_features,columns=['feature','genre'])
extracted_features_df.head()

extracted_features_df['genre'].value_counts()

df = pd.read_csv('/content/drive/MyDrive/Colab_Notebooks/Music_Genre_Classification/dataset/Data/features_3_sec.csv')
df.head()

extracted_features_df.shape

df.dtypes

df = df.drop(labels='filename', axis=1)

df.shape[0]

"""**Split the Dataset into Dependant and Independant dataset**"""

class_list = df.iloc[:, -1]
convertor = LabelEncoder()

class_list

y = convertor.fit_transform(class_list)
y

print(df.iloc[:, :-1])

fit = StandardScaler()
X = fit.fit_transform(np.array(df.iloc[:, :-1], dtype=float))
X.shape[0]

"""**Train Test Split**"""

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3)

len(y_test)

"""**Function for Training the Model**"""

def train_model(model, epochs,optimizer):
  batch_size = 256
  model.compile(optimizer = optimizer, loss = 'sparse_categorical_crossentropy', metrics = 'accuracy')
  return model.fit(X_train, y_train, validation_data=(X_test,y_test),epochs=epochs,batch_size=batch_size)

"""**Function for Plotting the Validation Accuracy**"""

def Validation_plot(history):
    print("Validation Accuracy",max(history.history["val_accuracy"]))
    pd.DataFrame(history.history).plot(figsize=(12,6))
    plt.show()

"""**Building and Training the Model**"""

model=tf.keras.models.Sequential([
    tf.keras.layers.Flatten(input_shape=(X.shape[1],)),
    tf.keras.layers.Dropout(0.2),
    
    tf.keras.layers.Dense(512,activation='relu', input_shape=(58,)),
    keras.layers.Dropout(0.2),
    
    tf.keras.layers.Dense(256,activation='relu'),
    tf.keras.layers.Dropout(0.2),
    
    tf.keras.layers.Dense(128,activation='relu'),
    tf.keras.layers.Dropout(0.2),
    
    tf.keras.layers.Dense(64,activation='relu'),
    tf.keras.layers.Dropout(0.2),
    
    tf.keras.layers.Dense(10,activation='softmax'),
])

model_history = train_model(model=model, epochs=600, optimizer='adam')

model.summary()

model.save("Model1")

"""**Test Loss and Test Accuracy**"""

model1 = keras.models.load_model("Model1")
test_loss, test_acc = model1.evaluate(X_test, y_test, batch_size=256)
print("Test Loss: ",test_loss)
print("\nTest Accuracy: ",test_acc*100)

Validation_plot(model_history)

"""**Predicting the Genre**"""

y_pred = model1.predict(X_test)
y_pred = np.argmax(y_pred, axis=1)

prediction = model1.predict(X_test)
predicted_index = np.argmax(prediction, axis = 1)
print("Expected Index: {}".format(y_test))
print("Predicted Index: {}".format(predicted_index))

filename="/content/drive/MyDrive/Colab_Notebooks/Music_Genre_Classification/dataset/Data/genres_original/hiphop/hiphop.00052.wav"

audio, sample_rate = librosa.load(filename, res_type='kaiser_fast') 
mfccs_features = librosa.feature.mfcc(y=audio, sr=sample_rate, n_mfcc=58)
mfccs_scaled_features = np.mean(mfccs_features.T,axis=0)
mfccs_scaled_features=mfccs_scaled_features.reshape(1,-1)

predicted_label = np.argmax(model1.predict(mfccs_scaled_features), axis=1)
print(predicted_label)
prediction_class = convertor.inverse_transform(predicted_label) 
print(prediction_class)

"""**Performance Metrics**"""

print('Accuracy: ', accuracy_score(y_test, y_pred))
print('Precision: ', precision_score(y_test, y_pred, average="macro"))
print('Recall: ', recall_score(y_test, y_pred, average="macro"))
print('F1: ', f1_score(y_test, y_pred, average="macro"))

"""**Confusion Matrix**"""

#Confusion Matrix
cf_matrix1 = confusion_matrix(y_test, y_pred)
print(cf_matrix1)

#Normalized Confusion Matrix
cf_matrix2 = confusion_matrix(y_test, y_pred, normalize='true')
print(cf_matrix2)

#Confusion Matrix
fig,ax = plt.subplots(figsize=(15,15))
ax = sns.heatmap(cf_matrix1, annot=True, cmap='Blues')

ax.set_title('Confusion Matrix with Labels\n\n');
ax.set_xlabel('\nPredicted Genre')
ax.set_ylabel('Actual Genre');

ax.xaxis.set_ticklabels(['Blues','Classical','Country','Disco','Hiphop','Metal','Pop','Reggae','Rock','Jazz'])
ax.yaxis.set_ticklabels(['Blues','Classical','Country','Disco','Hiphop','Metal','Pop','Reggae','Rock','Jazz'])

plt.figure(figsize=(100,100))
plt.show()

#Normalized Confusion Matrix
fig,ax = plt.subplots(figsize=(15,15))
ax = sns.heatmap(cf_matrix2, annot=True, cmap='Blues')

ax.set_title('Normalized Confusion Matrix with Labels\n\n');
ax.set_xlabel('\nPredicted Genre')
ax.set_ylabel('Actual Genre');

ax.xaxis.set_ticklabels(['Blues','Classical','Country','Disco','Hiphop','Metal','Pop','Reggae','Rock','Jazz'])
ax.yaxis.set_ticklabels(['Blues','Classical','Country','Disco','Hiphop','Metal','Pop','Reggae','Rock','Jazz'])

plt.figure(figsize=(100,100))
plt.show()